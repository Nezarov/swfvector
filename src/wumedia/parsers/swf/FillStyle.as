/* * Copyright 2009 (c) Guojian Miguel Wu, guojian@wu-media.com | guojian.wu@ogilvy.com * * Permission is hereby granted, free of charge, to any person * obtaining a copy of this software and associated documentation * files (the "Software"), to deal in the Software without * restriction, including without limitation the rights to use, * copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following * conditions: * * The above copyright notice and this permission notice shall be * included in all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR * OTHER DEALINGS IN THE SOFTWARE. */package wumedia.parsers.swf {	import flash.display.GradientType;
	import flash.geom.Matrix;		
	/**	 * @author guojian@wu-media.com | guojian.wu@ogilvy.com	 */	public class FillStyle {		public function FillStyle(data:Data, hasAlpha:Boolean) {			var i:int;			var fillType:int = data.readUnsignedByte();			if ( fillType == 0x00 ) {				_solidColor = new Color(data, hasAlpha);				_method = "beginFill";				_arguments = [_solidColor.color, _solidColor.alpha];				type = "FS";			} else if ( fillType == 0x10 || fillType == 0x12 || fillType == 0x13 ) {				// gradient - linear || radial || focal radial				var numRatios:int;				var ratios:Array;				var colors:Array;				_fillMatrix = data.readMatrix();       			       			numRatios = data.readUnsignedByte();				ratios = new Array(numRatios);				colors = new Array(numRatios);				for ( i = 0; i < numRatios; ++i ) {					ratios[i] = data.readUnsignedByte();					colors[i] = new Color(data, hasAlpha);				}				if ( fillType == 0x10 ) {					_arguments = [GradientType.LINEAR];				} else if ( fillType == 0x12 ) {					_arguments = [GradientType.RADIAL];				} else /*if ( fillType == 0x13 )*/ {					_arguments = [GradientType.RADIAL];				}				_arguments = _arguments.concat([colors.map(mapColors), colors.map(mapAlphas), ratios]);				_method = "beginGradientFill";				type = "FG";			} else if ( fillType == 0x40 || fillType == 0x41 || fillType == 0x42 || fillType == 0x43 ) {				// repeat bitmap || regular bitmap || non-smooth repeat || no-smooth regular				// TODO - not yet implemented				var bitmapId:uint;				bitmapId = data.readUnsignedShort();				_fillMatrix = data.readMatrix();				_method = "beginBitmapFill";				type = "FB";			} else {				type = "FS";				_method = "beginFill";				_arguments = [0xffffff];			}		}				public var type			:String;		private var _solidColor	:Color;		private var _fillMatrix :Matrix;		private var _method		:String;		private var _arguments	:Array;				public function apply(graphics:*, scale:Number = 1.0, offsetX:Number = 0.0, offsetY:Number = 0.0):void {			if ( graphics["hasOwnProperty"](_method) ) {				if ( type == "FS" ) {					graphics[_method].apply(null, _arguments);				} else {					var mat:Matrix = _fillMatrix.clone();					mat.scale(scale, scale);					mat.translate(offsetX, offsetY);					graphics[_method].apply(null, _arguments.concat(mat));				}			}		}		private function mapColors(c:Color, ...args):uint { return c.color;}		private function mapAlphas(c:Color, ...args):uint { return c.alpha;}		public function get method():* { return _method;}			}}